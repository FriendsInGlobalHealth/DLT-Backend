package dlt.dltbackendmaster.domain;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.MapsId;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.node.ObjectNode;

import dlt.dltbackendmaster.serializers.BeneficiarySerializer;
import dlt.dltbackendmaster.serializers.VulnerabilitySerializer;

@SuppressWarnings("serial")
@Entity
@Table(name = "beneficiaries_vulnerabilities")
@NamedQueries({ @NamedQuery(name = "BeneficiaryVulnerability.findAll",
                            query = "SELECT b FROM BeneficiaryVulnerability b"),
                @NamedQuery(name = "BeneficiaryVulnerability.findByDateCreated",
                            query = "select b from BeneficiaryVulnerability b where b.dateUpdated is null and b.dateCreated > :lastpulledat"),
                @NamedQuery(name = "BeneficiaryVulnerability.findByDateUpdated",
                            query = "select b from BeneficiaryVulnerability b where (b.dateUpdated >= :lastpulledat) or (b.dateUpdated >= :lastpulledat and b.dateCreated = b.dateUpdated)") })
public class BeneficiaryVulnerability implements Serializable
{
    private Beneficiary beneficiary;
    private Vulnerability vulnerability;
    private String value;
    private Date evaluationDate;
    private Integer status;
    private Integer createdBy;
    private Date dateCreated;
    private Integer updatedBy;
    private Date dateUpdated;
    private String offlineId;

    public BeneficiaryVulnerability() {}

    public BeneficiaryVulnerability(Beneficiary beneficiary, Vulnerability vulnerability, String value,
                                    Date evaluationDate, Integer status, Integer createdBy, Date dateCreated,
                                    Integer updatedBy, Date dateUpdated, String offlineId) {
        super();
        this.beneficiary = beneficiary;
        this.vulnerability = vulnerability;
        this.value = value;
        this.evaluationDate = evaluationDate;
        this.status = status;
        this.createdBy = createdBy;
        this.dateCreated = dateCreated;
        this.updatedBy = updatedBy;
        this.dateUpdated = dateUpdated;
        this.offlineId = offlineId;
    }

    @Id
    @ManyToOne
    @MapsId("beneficiaryId")
    @JsonProperty("beneficiary")
    @JsonSerialize(using = BeneficiarySerializer.class)
    public Beneficiary getBeneficiary() {
        return beneficiary;
    }

    public void setBeneficiary(Beneficiary beneficiary) {
        this.beneficiary = beneficiary;
    }

    @Id
    @ManyToOne
    @MapsId("vulnerabilityId")
    @JsonProperty("vunerability")
    @JsonSerialize(using = VulnerabilitySerializer.class)
    public Vulnerability getVulnerability() {
        return vulnerability;
    }

    public void setVulnerability(Vulnerability vulnerability) {
        this.vulnerability = vulnerability;
    }

    @Column(name = "value")
    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @Column(name = "evaluation_date")
    public Date getEvaluationDate() {
        return evaluationDate;
    }

    public void setEvaluationDate(Date evaluationDate) {
        this.evaluationDate = evaluationDate;
    }

    @Column(name = "status")
    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    @Column(name = "created_by", nullable = false)
    public Integer getCreatedBy() {
        return createdBy;
    }

    public void setCreatedBy(Integer createdBy) {
        this.createdBy = createdBy;
    }

    @Column(name = "date_created", nullable = false)
    public Date getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(Date dateCreated) {
        this.dateCreated = dateCreated;
    }

    @Column(name = "updated_by")
    public Integer getUpdatedBy() {
        return updatedBy;
    }

    public void setUpdatedBy(Integer updatedBy) {
        this.updatedBy = updatedBy;
    }

    @Column(name = "date_updated")
    public Date getDateUpdated() {
        return dateUpdated;
    }

    public void setDateUpdated(Date dateUpdated) {
        this.dateUpdated = dateUpdated;
    }

    public ObjectNode toObjectNode() {
        ObjectMapper mapper = new ObjectMapper();
        ObjectNode beneficiaryVulnerability = mapper.createObjectNode();
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

        if (offlineId != null) {
            beneficiaryVulnerability.put("id", offlineId);
        } else {
            beneficiaryVulnerability.put("id", beneficiary.getId() + "" + vulnerability.getId());
        }

        if (dateUpdated == null || dateUpdated.after(dateCreated)) {
            beneficiaryVulnerability.put("beneficiary_id", beneficiary.getId());
            beneficiaryVulnerability.put("subService_id", vulnerability.getId());
            beneficiaryVulnerability.put("value", value);
            beneficiaryVulnerability.put("evaluation_date", dateFormat.format(evaluationDate));
            beneficiaryVulnerability.put("status", status);
            beneficiaryVulnerability.put("online_id", beneficiary.getId() + "" + vulnerability.getId()); // flag to control if entity is synchronized with the backend
        } else { // ensure online_id is updated first
            beneficiaryVulnerability.put("online_id", beneficiary.getId() + "" + vulnerability.getId());
        }
        return beneficiaryVulnerability;
    }
}
